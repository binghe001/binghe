## 高并发之——如何利用面向对象思想写好并发程序？

## 写在前面

> 最近，有小伙伴留言，现在大部分开发都是面向对象开发，那如何以面向对象的方式写好并发程序呢？那好，今天我们就来聊聊这个话题。

## 前言

面向对象思想与并发编程有关系吗？本来二者是没有什么鸟关系的！它们是分属两个不同的领域，但是，Java却将二者融合在一起了！而且融合的效果不错：<font color="#FF0000">**我们利用Java的面向对象的思想能够让并发编程变得更加简单！！**</font>

那我们如何利用面向对象的思想写好并发程序呢？我们可以从下面三个角度进行分析。

* 封装共享变量
* 识别共享变量间的约束条件
* 指定并发访问策略

## 封装共享变量

在编写并发程序时，我们关注的一个核心问题，其实就是<font color="#FF0000">**解决多线程同时访问共享变量的问题！**</font>

面向对象思想中有一个很重要的特性：封装。简单的说，封装就是将属性和实现细节封装到对象的内部，外界对象只能通过目标对象提供的公共方法来间接访问内部属性。我们把共享变量作为对象的属性，那么，对于共享变量的访问路径就是对象的公共方法，所有公共方法的入口都要设置并发访问策略。

所以，我们得出一个结论：<font color="#FF0000">**利用面向对象思想写并发程序其实挺简单，就是将共享变量作为对象属性封装在内部，对所有的公共方法指定并发访问策略！**</font>

比如，我们在很多业务场景中都会用到计数器，我们可以将计数器类定义成如下所示。

```java
public class Counter{
    private long count;
    public synchronized long incrementCount(){
        return ++count;
    }
    public synchronized long getCount(){
        return count;
    }
}
```

在上面的Counter类中，存在一个共享变量count，对外提供的两个公共方法incrementCount()和getCount()设置了synchronized同步锁，此时，Counter类就是一个线程安全的类了。

在实际工作中，很多场景比计数器的实现复杂的多，比如，我们的银行账户中，有卡号、姓名、身份证、余额等共享变量，我们没有必要对每个共享变量都要考虑并发问题。此时，我们就需要仔细分析这些共享变量，看这些共享变量中哪些变量是不变的。对于我们的银行账户来说，卡号、姓名、身份证这三个共享变量就是不变的。<font color="#FF0000">**对于这些不变的共享变量，我们可以使用final关键字来修饰它们，避免并发问题。**</font>

<font color="#FF0000">**最后，需要注意的是，对共享变量进行封装时，要注意”对象逃逸“的问题！例如，下面的程序代码，在构造函数中将this赋值给了全局变量global.obj，此时对象初始化还没有完成，此时对象初始化还没有完成，此时对象初始化还没有完成，重要的事情说三遍！！线程通过global.obj读取的x值可能为0。此时对象this就“逃逸”了。**</font>

```java
final x = 0;
public FinalFieldExample() { // bad!
  x = 3;
  y = 4;
  // bad construction - allowing this to escape
  global.obj = this;
}
```

以上示例来源于：[http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong)

## 识别共享变量间的约束条件

<font color="#FF0000">**共享变量间的约束条件非常重要，因为它们决定了并发访问策略。**</font>

例如，在商城业务中，对于商品的库存管理中有个合理库存的概念，库存量不能太高，也不能太低，这个值有一个上限和一个下限。例如，下面的类模拟了这个合理的库存概念。

```java
public class Stock{
    //库存的上限
    private final AtomicLong upper = new AtomicLong(0);
    //库存的下限
    private final AtomicLong lower = new AtomicLong(0);
    //设置库存上限
    public void setUpper(long v){
        upper.set(v);
    }
    //设置库存下限
    public void setLower(long v){
        lower.set(v);
    }
    //其他众多的代码省略
}
```

乍一看，上面的程序没问题啊！但是，其忽略了一个约束条件，就是<font color="#FF0000">**库存的下限要小于库存的上限。**</font>这也是很多人容易忽略的问题。

看到这里，很多人的第一反应就是在setUpper()方法和setLower()方法中，添加参数校验逻辑，例如，改造后的Stock类如下所示。

```java
public class Stock{
    //库存的上限
    private final AtomicLong upper = new AtomicLong(0);
    //库存的下限
    private final AtomicLong lower = new AtomicLong(0);
    //设置库存上限
    public void setUpper(long v){
        if(v < lower.get()){
            throw new IllegalArgumentException();
        }
        upper.set(v);
    }
    //设置库存下限
    public void setLower(long v){
        if(v > upper.get()){
             throw new IllegalArgumentException();
        }
        lower.set(v);
    }
    //其他众多的代码省略
}
```

<font color="#FF0000">**这样设置正确吗？答案是：这样设置完全不同保证库存的下限小于库存的上限。**</font>

<font color="#FF0000">**其实，这里存在竞态条件（当程序中出现 if 语句的时候，应该首先反应出程序是否有竞态条件），关于竞态条件的详细讲解可以参见《[【高并发】要想学好并发编程，关键是要理解这三个核心问题](https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&mid=2247484183&idx=1&sn=530d507f9181d69a4f340d15adf4262f&chksm=cee51cdaf99295ccbd7bc0ac244549fab65ce5528b79d1a490092b4e7fcc71cbb448fa305900&token=1948862373&lang=zh_CN#rd)》。**</font>

假设，原有库存的上限为10，下限为3。此时线程A调用setUpper(5)将库存的上限设置为5，线程B调用setLower(7)将库存的下限设置为8，如果线程A和线程B同时执行，线程A会通过参数校验，因为此时库存的下限还没有被线程B设置完毕，此时的库存下限还是3，5>3成立，所以，线程A会将库存的上限设置为5。同样的，线程B也能够通过参数校验，因为此时库存的上限还没有被线程A设置完毕，此时库存的上限还是10，8<10成立，线程B会将库存的下限设置为8。最终的结果为：库存的上限为5，下限为8。库存的上限小于下限，不满足上限小于下限的约束条件。

<font color="#FF0000">**所以，大家在识别共享变量间的约束条件时，一定要注意竞态条件的问题！**</font>

## 制定并发访问策略

制定并发访问策略比较复杂，它需要结合具体的业务场景进行选择。但是从方案上，我们可以将其总结成如下方案。

### 避免共享

可以利用线程本地存储和为每个任务分配独立的线程来避免共享。

### 不变模式

这个在Java中使用的比较少，在其他的领域使用的比较多，例如Actor模式，CSP模式和函数式编程。

### 管程和其他同步工具

Java中对于并发编程万能的解决方案就是管程（关于什么是管程后面的文章会讲解），但是对于很多特定的并发场景来说，使用Java并发包提供的读写锁、并发容器等同步工具比较好。

我们在编写并发程序时，也要遵循一定的原则，这些原则可以归纳如下。

### 优先使用成熟的工具类

对于并发编程来说，我们最好优先使用Java中提供的并发工具类，因为这些并发工具类基本上能够满足大部分并发的业务场景。

### 尽量不要使用低级的同步原语

低级的同步原语指的是synchronized，Lock和Semaphore等，这些使用起来虽然简单，但实际上并没有那么简单，使用的时候一定要小心。不到万不得已的时候，尽量不要使用它们。

### 避免过早优化

安全第一，并发编程首先要保证的就是线程安全，出现性能瓶颈之后再优化，不要过早和过度的优化。

## 写在最后

> 如果觉得文章对你有点帮助，请微信搜索并关注「 **冰河技术** 」微信公众号，跟冰河学习高并发编程技术。

最后，附上并发编程需要掌握的核心技能知识图，祝大家在学习并发编程时，少走弯路。

![sandahexin_20200322](images/sandahexin_20200322.jpg)



> 如果你觉得冰河写的还不错，请微信搜索并关注「 **冰河技术** 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 **冰河技术** 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 **冰河技术** 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 **冰河技术** 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！


![](https://img-blog.csdnimg.cn/20200906013715889.png)








